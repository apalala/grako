(*
    ANTLR v3 grammar written in Grako EBNF syntax.

    This grammar is inspired in, but different one by the one created
    by Terence Parr using ANTLR syntax. It is licensed under the BSD
    License to keep in the spirit of ANTLR.
*)

grammar
    =
    [('lexer'|'parser')] 'grammar' id ';'
    [options]
    [tokens]
    {scope}
    {action}
    {rule}+
    $
    ;

options
    =
    'options' '{' {option}+ '}'
    ;

option
    =
    id '='  (id|string|char|int|'*') ';'
    ;

tokens
    =
    'tokens' '{' {token}+ '}'
    ;

token
    =
    token_name ['=' token_value ] ';'
    ;

token_value
    =
    literal
    ;

scope
    =
    'scope'
    (
      block ['scope' id {',' id} ';' ]
    | id {',' id} ';'
    | id block
    )
    ;

action
    =
    '@' ('lexer'|'parser'|id) block
    ;

block
    =
    '{' {(block|?/./?)} '}'
    ;

rule
    =
    ['protected'|'public'|'private'|'fragment']
    id ['!'] [arg]
    ['returns' arg]
    ['trhows' id {',' id}* ]
    [options]
    [scope]
    {action}
    ':' alternatives ';'
    [exceptions]
    ;

arg
    =
    '['
        {
            arg
        |
            ?/[^\]]*/?
        }*
    ']'
    ;

exceptions
    =
    {'catch' arg block}
    ['finally' block]
    ;

alternatives
    =
    alternative {'|' alternative}
    ;

alternative
    =
    {element}* [rewrite]
    ;

element
    =
      id ('+='| '=')  atom
    | semantic
    | syntactic
    | optional
    | closure
    | positive_closure
    | atom
    ;

semantic
    =
    block '?'
    ;

syntactic
    =
    block '=>'
    ;

optional
    =
    atom '?'
    ;

closure
    =
    atom '*'
    ;

positive_closure
    =
    atom '+'
    ;

atom
    =
    ['^'|'!']
    (
      negative
    | range
    | terminal
    | rule_ref
    | subexp
    | terminal
    | non_terminal
    )
    ;

range
    =
    char '..' char
    ;

subexp
    =
    '(' alternatives ')'
    ;

negative
    =
    '~' (non_terminal|subexp)
    ;

non_terminal
    =
      rule_ref
    | token_ref
    ;

terminal
    =
      char
    | string
    | '.'
    ;


rewrite
    =
    '->' ?/[^|;]*/?
    ;

rule_ref
    =
    lower_name
    ;

token_ref
    =
    upper_name
    ;

token_name
    =
    upper_name
    ;

literal
    =
    id | string | int
    ;


id
    =
    lower_name
    ;

lower_name
    =
    ?/[a-z]/? NAME_CHARS
    ;

upper_name
    =
    ?/[A-Z]/? NAME_CHARS
    ;

NAME_CHARS
    =
    ?/[A-Za-z0-9_]*/?
    ;

char
    =
    string
    ;

string
    =
    '"' ?/([^"\n]|"")*/? '"'
    |
    "'" ?/([^'\n]|'')*/? "'"
    |
    "<<" ?/.*(?!>>)/? ">>"
    ;

int =
    ?/[0-9]+/?
    ;
