(*
 * This grammar defines the Grako variation of EBNF.
 *
 * Grako uses its own hand-written bootstrap parser, and this
 * grammar is only used for testing.
 *
 * See the accompanying README for details.
 *
 *)


grammar
    =
    @{rule}+
    $
    ;

rule
    =
    name:word ^
    [
        '::' ^ params:params
    |
        '('  ^
            (
                kwparams:kwparams
            |
                params:params ',' ^ kwparams:kwparams
            |
                params:params
            )
        ')'
    ]
    '=' ^
    rhs:expre
    ';' ^
    ;

params
    =
    @+:literal {',' ^ @+:literal}
    ;

kwparams
    =
    @+:pair {',' ^ @+:pair}
    ;

pair
    =
    @+:word '=' ^ @+:literal
    ;

expre
    =
      choice
    | sequence
    ;

choice
    =
    @+:sequence {'|' ^ @+:sequence}+
    ;

sequence
    =
    {element}+
    ;

element
    =
      named_list
    | named
    | override_list
    | override
    | term
    ;

named_list
    =
    name:name '+:' value:element
    ;

named
    =
    name:name ':' value:element
    ;

name
    =
    word
    ;

override_list
    =
    '@+:' ^ @element
    ;

override
    =
    ('@:'|'@') ^ @element
    ;

term
    =
      void
    | group
    | positive_closure
    | closure
    | optional
    | special
    | kif
    | knot
    | atom
    ;

group
    =
    '(' ^ @:expre ')' ^
    ;

positive_closure
    =
    '{'  @:expre '}' ('-' | '+')  ^
    ;

closure
    =
    '{' @:expre '}' ^ ['*'] ^
    ;

optional
    =
    '[' ^ @:expre ']' ^
    ;

special
    =
    '?(' ^ @:?/(.*)/? ')?' ^
    ;

kif
    =
    '&' ^ @:term
    ;

knot
    =
    '!' ^ @term
    ;

atom
    =
      cut
    | token
    | call
    | pattern
    | eof
    ;

call
    =
    word
    ;

void
    =
    '()' ^
    ;

cut
    =
    ('^' | '>>') ^
    ;

literal
    =
      token
    | number
    | word
    ;

token
    =
      '"' ^ @:?/([^"\n]|\\"|\\\\)*/? '"'
    | "'" ^ @:?/([^'\n]|\\'|\\\\)*/? "'"
    ;

number
    =
    ?/[0-9]+/?
    ;

word
    =
    ?/[-_A-Za-z0-9]+/?
    ;

pattern
    =
    '?/' ^ @:?/(.*?)(?=/\?)/? '/?' ^
    ;

eof
    =
    '$' ^
    ;
